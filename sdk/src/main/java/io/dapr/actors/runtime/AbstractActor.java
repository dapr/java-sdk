/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */
package io.dapr.actors.runtime;

import io.dapr.actors.ActorId;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.time.Duration;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * TODO - this is the base class Actor implementations (user code) will extend.
 */
public abstract class AbstractActor<T extends AbstractActor> {

  private final ActorId id;

  private final ActorRuntime actorRuntime;

  private final ActorStateSerializer actorSerializer;

  private final ActorService<T> actorService;

  private final ActorStateManager<T> actorStateManager;

  private final Map<String, ActorTimer<?>> timers;

  protected AbstractActor(ActorRuntimeContext runtimeContext, ActorId id) {
    this.id = id;
    this.actorRuntime = runtimeContext.getActorRuntime();
    this.actorSerializer = runtimeContext.getActorSerializer();
    this.actorService = runtimeContext.getActorService();
    this.actorStateManager = new ActorStateManager<T>(runtimeContext.getActorTypeInformation().getName(), id);
    this.timers = Collections.synchronizedMap(new HashMap<>());
  }

  /**
   * Registers a Timer for the actor. A timer name is autogenerated by the runtime to keep track of it.
   *
   * @param timerName Name of the timer, unique per Actor (auto-generated if null).
   * @param methodName Name of the method to be called.
   * @param state State object to be passed it to the method when timer triggers.
   * @param dueTime The amount of time to delay before the async callback is first invoked.
   *                Specify negative one (-1) milliseconds to prevent the timer from starting.
   *                Specify zero (0) to start the timer immediately.
   * @param period The time interval between invocations of the async callback.
   *               Specify negative one (-1) milliseconds to disable periodic signaling.
   * @param <T> Type for the state object.
   * @return Asynchronous result.
   */
  protected <T> Mono<Void> RegisterActorTimer(String timerName, String methodName, T state, Duration dueTime, Duration period) throws IOException {
    String name = timerName;
    if ((timerName == null) || (timerName.isEmpty())) {
      name = String.format("%s_Timer_%d", this.id);
    }

    ActorTimer<T> actorTimer = new ActorTimer(this, name, methodName, state, dueTime, period);
    String serializedState = this.actorSerializer.serialize(actorTimer);
    this.timers.put(name, actorTimer);
  }

  protected Mono<Void> onPreActorMethod(ActorMethodContext actorMethodContext) {
    return Mono.empty();
  }

  protected Mono<Void> onPostActorMethod(ActorMethodContext actorMethodContext) {
    return Mono.empty();
  }

  protected Mono<Void> saveState() {
    return this.actorStateManager.SaveState();
  }

  ActorTimer getActorTimer(String timerName)
  {
    return timers.getOrDefault(timerName, null);
  }

  Mono<Void> onPreActorMethodInternal(ActorMethodContext actorMethodContext) {
    return this.onPreActorMethod(actorMethodContext);
  }

  Mono<Void> onPostActorMethodInternal(ActorMethodContext actorMethodContext) {
    return this.onPostActorMethod(actorMethodContext);
  }
}
